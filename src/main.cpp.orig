/*
Chipulator, a Chip-8 emulator written in C++ with SFML, by Mischa 'Aster' Alff.
*/
#include <string>
#include <iostream>
<<<<<<< HEAD
#include <fstream>
#include <array>
#include "vertextable.h"
=======
#include <SFML/Graphics.hpp>
#include <Chipulator/Chipulator.hpp>
>>>>>>> v2_rewrite

int translate_key(sf::Keyboard::Key key)
{
<<<<<<< HEAD
public:
	enum error_code
	{
		NONE,
		LOADING_FILE,
		INSTRUCTION_NOT_FOUND
	};

private:

	//Constants. Define what a byte is, 
	// and where the program's RAM accessing 
	// will start and stop.
	using byte        = uint8_t;
	using double_byte = uint16_t;
	const double_byte memory_start = 0x200;
	const double_byte memory_end   = 0xFFF;

	//Miscellaneous stuff
	std::string filename;

	//Graphics stuff
	sf::RenderWindow &window;
	std::array<std::array<bool, 32>, 64> display;
	vertexTable screen;

	//The actual emulator.
	//Current opcode. Two bytes because Wikipedia said so.
	double_byte opcode;
	//The program counter when reading the program
	int program_counter, program_size;
	std::vector<int> call_stack;
	// RAM. 4096 bytes because Wikipedia said so.
	byte memory[4096];
	// 16 registers ( 0 through F ) including flags.
	byte registers[16];
	double_byte address_register;
	//Timers, both decremented at 60Hz
	//When timer_sound reaches 0, play a beep.
	//These are stored in the Chip-8 RAM, so
	// we'll keep them as references.
	byte &timer_delay{memory[0x8]}, timer_sound{memory[0x9]};
	//Fonts are stored in the Chip-8 RAM,
	// since we define them, we also keep
	// their position.
	byte font_pos = 0x50;



	//Just a few helper functions to make
	// code cleaner
	inline const bool get_bit(const byte &a, const int &pos)
	{
		return ((a>>(0x8-pos))&1);
	}
	inline const bool get_bit(const double_byte &a, const int &pos)
	{
		return ((a>>(0xF-pos))&1);
	}
	inline const byte get_4bit(const byte &a, const int &pos)
	{
		return ((a>>((0x1-pos)*4))&0xF);
	}
	inline const byte get_4bit(const double_byte &a, const int &pos)
	{
		return ((a>>((0x3-pos)*4))&0xF);
	}
	inline const byte get_byte(const double_byte &a, const int &pos)
	{
		return ((a>>((0x1-pos)*8))&0xFF);
=======
	switch(key)
	{
		case sf::Keyboard::Numpad0:
			return 0x0;
		case sf::Keyboard::Numpad1:
			return 0x7;
		case sf::Keyboard::Numpad2:
			return 0x8;
		case sf::Keyboard::Numpad3:
			return 0x9;
		case sf::Keyboard::Numpad4:
			return 0x4;
		case sf::Keyboard::Numpad5:
			return 0x5;
		case sf::Keyboard::Numpad6:
			return 0x6;
		case sf::Keyboard::Numpad7:
			return 0x1;
		case sf::Keyboard::Numpad8:
			return 0x2;
		case sf::Keyboard::Numpad9:
			return 0x3;
		case sf::Keyboard::Num1:
			return 0xA;
		case sf::Keyboard::Num2:
			return 0xB;
		case sf::Keyboard::Num3:
			return 0xC;
		case sf::Keyboard::Num4:
			return 0xD;
		case sf::Keyboard::Num5:
			return 0xE;
		case sf::Keyboard::Num6:
			return 0xF;
>>>>>>> v2_rewrite
	}
	return 0x0;
}

void handle_events(sf::Event &event, Chipulator &chip8, sf::RenderWindow &window)
{
	switch(event.type)
	{
		case sf::Event::KeyPressed:
			chip8.key_pressed(translate_key(event.key.code));
			return;
			break;
		case sf::Event::KeyReleased:
			chip8.key_released(translate_key(event.key.code));
			return;
			break;
		case sf::Event::Closed:
			window.close();
			return;
			break;
	}
}

<<<<<<< HEAD
	std::map<byte, sf::Keyboard::Key> keymap
	{
		{0x0, sf::Keyboard::X},
		{0x1, sf::Keyboard::Num1},
		{0x2, sf::Keyboard::Num2},
		{0x3, sf::Keyboard::Num3},
		{0x4, sf::Keyboard::Q},
		{0x5, sf::Keyboard::W},
		{0x6, sf::Keyboard::E},
		{0x7, sf::Keyboard::A},
		{0x8, sf::Keyboard::S},
		{0x9, sf::Keyboard::D},
		{0xA, sf::Keyboard::Z},
		{0xB, sf::Keyboard::C},
		{0xC, sf::Keyboard::Num4},
		{0xD, sf::Keyboard::R},
		{0xE, sf::Keyboard::F},
		{0xF, sf::Keyboard::V}
	};

	std::map<sf::Keyboard::Key, bool> keys_pressed;
=======
int main(int argc, char** argv)
{
	if(argc <= 0)
		return -1;
>>>>>>> v2_rewrite

	std::string name{argv[1]};
	name = "Chipulator :: "+name;

	sf::RenderWindow window{{640, 320}, name};
	Chipulator chip8;
		chip8.load_program({argv[1]});

	sf::RectangleShape pixel({10.f,10.f});
	pixel.setFillColor(sf::Color::White);

	auto timer_period = 1e6f/60.f;
	sf::Clock timer, total;
	timer.restart();
	total.restart();

	while(chip8.running())
	{
		sf::Event event;
		window.pollEvent(event);
		handle_events(event, chip8, window);

		if(timer.getElapsedTime().asMicroseconds() > timer_period)
		{
			timer.restart();
			chip8.decrement_timers();
		}

		try
		{
			chip8.run_opcode();
		}
<<<<<<< HEAD
	}

	void clear_registers()
	{
		for(int i = 0; i < 0xF; ++i)
			registers[i]=0;
	}

	//This is the draw function.
	//It draws a Chip-8 Sprite
	// at pos_x,pos_y with 
	// width=8 and height=height.
	//Sprite data is stored as
	// a set of bits in a byte
	// each bit represents a 
	// pixel of the sprite.
	//It returns the
	// pixel_overwritten flag.
	bool draw(const byte &pos_x, const byte &pos_y, const byte &height)
    {
        bool pixels_overwritten=false;
        
        for(int y = 0; y < height; ++y)
        {
            for(int x = 0; x < 7; ++x)
            {
                if(get_bit(memory[address_register+y], x))
                {
                    if(!pixels_overwritten && display[(x+pos_x)%display.size()][(y+pos_y)%display[0].size()])
                        pixels_overwritten = true;
                    display[(x+pos_x)%display.size()][(y+pos_y)%display[0].size()] = !display[(x+pos_x)%display.size()][(y+pos_y)%display[0].size()];
                }
            }
        }
        
        screen.update();
        
        window.draw(screen.getSprite());
        window.display();
        
        return pixels_overwritten;
    }

	//This function is the heart of
	// the program. It executes the
	// given opcodes.
	error_code execute_opcode()
	{
		// 0x00E0
		// Clear window opcode
		if(opcode == 0x00E0)
		{
			window.clear(sf::Color::Black);
			for(auto &row : display)
				std::fill(row.begin(), row.end(), false);

			program_counter +=2;
			return error_code::NONE;
		}

		// 0x00EE
		// Return from subroutine
		if(opcode == 0x00EE)
		{
			if(call_stack.size() > 0)
			{
				program_counter = call_stack.back();
				program_counter +=2;
				call_stack.pop_back();
			}
			return error_code::NONE;
		}

		// 0x0NNN
		//Call RCA program at NNN or something
		if(opcode <= 0x0FFF)
		{
			// TBI
			std::cout<<"Ran TBI opcode, 0x0NNN\n";
			program_counter +=2;
			return error_code::NONE;
		}

		// 0x1NNN
		// Jump to address at NNN
		if(opcode >= 0x1000 && opcode <= 0x1FFF)
		{
			program_counter = (opcode&0xFFF);
			return error_code::NONE;
		}

		// 0x2NNN
		// Call subroutine at NNN
		if(opcode >= 0x2000 && opcode <= 0x2FFF)
		{
			call_stack.push_back(program_counter);
			program_counter = (opcode&0xFFF);
			return error_code::NONE;
		}

		// 0x3XNN
		// Skip next instruction if registers[X]
		// is equal to NN
		if(opcode >= 0x3000 && opcode <= 0x3FFF)
		{
			if(registers[get_4bit(opcode, 1)] == get_byte(opcode, 1))
			{
				program_counter+=4;
=======
		catch(Chipulator::Exception e)
		{
			switch(e)
			{
				case Chipulator::WaitKey:
				{
					do
					{
						window.waitEvent(event);
						handle_events(event, chip8, window);
					}
					while(event.type != sf::Event::KeyPressed);
					break;
				}
>>>>>>> v2_rewrite
			}
		}
		window.clear(sf::Color::Black);
<<<<<<< HEAD

		//Reset timers
		timer_delay = 0;
		timer_sound = 0;

		//Load the file, return error if any
		if(!load_program(f_))
			return error_code::LOADING_FILE;

		//Set the window title
		window.setTitle("Chipulator: " + filename);

		//Seed rand, for random number generation
		srand(time(NULL));

		//Load font
		//This is done by the Chip-8
		// emulator, and the fonts are hardcoded
		load_font();

		clear_registers();


		program_counter = memory_start;
		//Commence loop
		while(window.isOpen() && program_counter < program_size+memory_start)
=======
		auto display = chip8.get_display();
		for(auto y=0;y<32;++y)
>>>>>>> v2_rewrite
		{
			for(auto x=0;x<64;++x)
			{
				if(display[y][x])
				{
					pixel.setPosition(x*10.f, y*10.f);
					window.draw(pixel);
				}
			}
<<<<<<< HEAD
			//Run the desired opcode and increment cursor
			opcode = (memory[program_counter] << 8) | memory[program_counter+1];

			if(false)
			{
				std::cout<<std::hex;
				std::cout<<"Stack size: "<<call_stack.size()<<"\n";
				std::cout<<"PC: "<<program_counter<<"\n";
				std::cout<<"Opcode: "<<opcode<<"\n";
				std::cout<<"\n\n";
			}
			if(false)
				for(int i = 0; i <= 0xF; i++)
					std::cout<<"\tRegisters["<<i<<"]: "<<std::dec<<(int)registers[i]<<"\n";

			error_code execution_return = execute_opcode();

			if(execution_return != error_code::NONE)
			{
				std::cout<<"Error! Code: "
				         <<std::hex<<std::uppercase<<execution_return
				         <<std::nouppercase<<", Instruction: "
				         <<std::uppercase<<opcode<<"\n";
				;
				return execution_return;
			}
			if(timer_delay > 0)
				timer_delay--;
			if(timer_sound > 0)
				timer_sound--;

			//sf::sleep(sf::milliseconds(5));
=======
>>>>>>> v2_rewrite
		}
		window.display();
		//std::cout<<total.getElapsedTime().asMicroseconds()<<std::endl;
		sf::sleep(sf::microseconds(100));
	}

<<<<<<< HEAD
	Chip8(sf::RenderWindow &w) : window(w),screen(display)
    {
        //scale screen sprite according to window size
        screen.getSprite().setScale(window.getSize().x/display.size(),window.getSize().y/display[0].size());
    }
};


int main()
{
	sf::RenderWindow window{{800,600}, "Chipulator!"};
	Chip8 emulator(window);
	int emulator_status = emulator.run("roms/TETRIS");
	if(emulator_status != Chip8::error_code::NONE)
		return emulator_status;
=======
	return 0;
>>>>>>> v2_rewrite
}



